<!doctype html>
<html lang="bg">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>DP DNA • Three.js Scroll Prototype</title>
<style>
  html,body{margin:0;padding:0;height:100%;background:#000;overflow-y:scroll;scroll-snap-type:y mandatory;overscroll-behavior:none;}
  section{height:100dvh;scroll-snap-align:start;display:flex;align-items:center;justify-content:center;color:#fff;font-family:Inter,Arial,sans-serif;}
  canvas#scene{position:fixed;inset:0;z-index:0;display:block;width:100%;height:100%;}
  .overlay{position:fixed;inset:0;z-index:1;display:flex;align-items:center;justify-content:center;pointer-events:none;flex-direction:column;text-align:center;}
  h1{font-size:3rem;margin:0.5em 0;}
  p{max-width:30rem;color:#aaa;font-size:1rem;}
</style>
</head>
<body>
<canvas id="scene"></canvas>

<div class="overlay">
  <h1 id="title">DP | Design</h1>
  <p id="subtitle">Това е нашето ДНК</p>
</div>

<section data-title="Design" data-sub="Precision"></section>
<section data-title="Productive" data-sub="Digital"></section>
<section data-title="Digital" data-sub="Performance"></section>
<section data-title="Финал" data-sub="DP Design"></section>

<script type="module">
import * as THREE from 'https://esm.sh/three@0.161.0';
import { OrbitControls } from 'https://esm.sh/three@0.161.0/examples/jsm/controls/OrbitControls.js';

const canvas = document.getElementById('scene');
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, powerPreference: 'high-performance' });
renderer.setClearColor(0x000000, 1);
renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
renderer.setSize(window.innerWidth, window.innerHeight);

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
camera.position.set(0, 0, 5.2);

// Controls disabled for production; kept to allow touch-rotate in dev if needed
const controls = new OrbitControls(camera, canvas);
controls.enablePan = false; controls.enableZoom = false; controls.enableRotate = false;

// Lights
scene.add(new THREE.AmbientLight(0x404040, 1.5));
const dirLight = new THREE.PointLight(0xffdd88, 1.2);
dirLight.position.set(4, 1.8, 4);
scene.add(dirLight);

// DNA group
const group = new THREE.Group();
scene.add(group);
const materialL = new THREE.MeshStandardMaterial({ color: 0x2b6eff, emissive: 0x0a2c7a, roughness: 0.2, metalness: 0.7 });
const materialR = new THREE.MeshStandardMaterial({ color: 0x00d0ff, emissive: 0x064a66, roughness: 0.2, metalness: 0.7 });

const radius = 0.04; // thicker dots
const steps = 240;
const height = 6.0;
const turns = 7.0;
const segGeo = new THREE.SphereGeometry(radius, 10, 10);
for (let i = 0; i < steps; i++) {
  const t = i / steps;
  const y = height * (t - 0.5);
  const ang = turns * Math.PI * 2 * t;
  const xL = Math.sin(ang) * 0.55;
  const zL = Math.cos(ang) * 0.55;
  const xR = -xL;
  const zR = -zL;
  const a = new THREE.Mesh(segGeo, materialL); a.position.set(xL, y, zL);
  const b = new THREE.Mesh(segGeo, materialR); b.position.set(xR, y, zR);
  group.add(a, b);
}
// Scale so it overflows viewport
group.scale.set(2.0, 2.0, 2.0);

// Particles (parallax)
const particles = new THREE.Group();
scene.add(particles);
const pGeo = new THREE.SphereGeometry(0.02, 6, 6);
const pMat = new THREE.MeshBasicMaterial({ color: 0x7aa7ff });
for (let i = 0; i < 420; i++) {
  const p = new THREE.Mesh(pGeo, pMat);
  p.position.set((Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10);
  particles.add(p);
}

function onResize() {
  renderer.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
}
window.addEventListener('resize', onResize);

// Sections & overlay text
const sections = document.querySelectorAll('section');
const title = document.getElementById('title');
const subtitle = document.getElementById('subtitle');

const clamp = (x, a, b) => Math.min(Math.max(x, a), b);
const lerp = (a, b, t) => a + (b - a) * t;
const ease = (x) => x < 0.5 ? 2 * x * x : 1 - Math.pow(-2 * x + 2, 2) / 2; // easeInOutQuad

function updateScene() {
  const docH = Math.max(1, document.body.scrollHeight - window.innerHeight);
  const progress = window.scrollY / docH; // 0..1
  const n = sections.length;
  const p = progress * n;
  const idx = Math.min(n - 1, Math.floor(p));
  const t = p - idx; // 0..1 within scene

  const cur = sections[idx];
  if (cur) {
    title.textContent = cur.dataset.title || '';
    subtitle.textContent = cur.dataset.sub || '';
  }

  // Text crossfade peak at center
  const vis = 1 - Math.abs(t - 0.5) * 2; // 0→1→0
  const alpha = clamp(0.3 + 0.7 * ease(clamp(vis, 0, 1)), 0, 1);
  title.style.opacity = alpha.toFixed(3);
  subtitle.style.opacity = (alpha * 0.9).toFixed(3);

  // Camera / scale / drift
  const scl = lerp(2.2, 1.5, ease(t));
  group.scale.set(scl, scl, scl);
  camera.position.z = lerp(4.8, 3.8, ease(t));
  group.position.y = lerp(0.6, -0.6, t) + (idx - (n - 1) / 2) * 0.15;

  // Light orbit → illusion of rotation
  const angle = progress * Math.PI * 2 * 1.2;
  dirLight.position.set(Math.cos(angle) * 4, 1.8, Math.sin(angle) * 4);

  // Particles subtle parallax
  particles.rotation.y += 0.0015;
  particles.position.z = lerp(-1.2, -2.5, progress);
}

function animate(){
  requestAnimationFrame(animate);
  updateScene();
  renderer.render(scene, camera);
}
animate();
</script>
</body>
</html>
